<p>In this article I’m going to do a quick recap of ES5 and ES6 functions, explaining what happens to <code class="highlighter-rouge">this</code>.</p>

<h2 id="functions-as-you-may-already-know-plain-old-classic-es5">Functions as you may already know: plain-old-classic ES5</h2>

<p>As you know, in javascript you can define a function in many ways. The standard, 20-years-old way of declaring a function is this:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"hello!"</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre>
</div>

<p>This kind of functions will be “hoisted”, this means that the function will be read before any other code, and used when called. So you can also write this with no error:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// no error, because the function declaration </span>
<span class="c1">// is read and hoisted</span>
<span class="nx">sayHello</span><span class="p">();</span> 

<span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"hello!"</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre>
</div>

<p>If you find this behaviour too strange (at first glance, it is!), you can <strong>assign a function to a variable</strong>. In this case the function will be read and executed only when used:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">//sayHello();  if called here, like before, ERROR! </span>

<span class="kd">var</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello!"</span><span class="p">)</span> 
<span class="p">}</span>

<span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// no error because it is used after the definition</span>
</code></pre>
</div>

<h2 id="functions-in-es6">Functions in ES6</h2>

<p>Now we can have a quick look to new kind of functions introduced in ES6. Here is the first example:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> 
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello, "</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">sayHello</span><span class="p">(</span><span class="s1">'Michele'</span><span class="p">);</span>
</code></pre>
</div>

<p>what happened? we have stripped out the <code class="highlighter-rouge">function</code> keyword, put an arrow (<code class="highlighter-rouge">=&gt;</code>) between the arguments and the body of the function, and that’s it! More expressive and fun to use.</p>

<h2 id="functions-in-es6-in-js-objects">Functions, in ES6, in JS Objects</h2>

<p>There is just one thing to note: <strong>the ES6 version of the function does not bind <code class="highlighter-rouge">this</code></strong>. What the heck does this mean?!</p>

<p>Have a look at this:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'Michele'</span><span class="p">,</span>
  <span class="na">sayHi</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Hi</span><span class="p">.</span> <span class="nx">I</span><span class="s1">'m ${this.name}`);
  },
  sayHiAlt () {
    console.log(`Hi. I'</span><span class="nx">m</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// "Hi. I'm undefined"</span>
<span class="nx">user</span><span class="p">.</span><span class="nx">sayHiAlt</span><span class="p">();</span> <span class="c1">// "Hi. I'm Michele"</span>
</code></pre>
</div>

<p>What’s happening? Let’s dip in.</p>

<h3 id="what-is-hi-im-thisname">what is <code class="highlighter-rouge">Hi. I'm ${this.name}</code>?</h3>

<p>This is a template string in Javascript. this translates in <code class="highlighter-rouge">"Hi. I\'m " + this.name</code>.</p>

<h3 id="why-the-first-sayhi-returns-undefined">Why the first <code class="highlighter-rouge">sayHi</code> returns undefined?</h3>

<p>because <code class="highlighter-rouge">this</code> is not bound!</p>

<h3 id="what-is-happening-at-the-last-function-sayhialt-">What is happening at the last function, <code class="highlighter-rouge">sayHiAlt</code> ?!</h3>

<p>this might seem strange, but this is ES6 at all of it’s power. First, this is like assigning a function to a variable, like we saw in the third example of this article.</p>

<p>Then, we are using another ES6 to assign the function to a property with the same name. Infact, thanks to <a href="babeljs.io/repl/">babel online repl</a> (a place where you can past ES6 code and see it in ES5), the previous code becomes this:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="s1">'use strict'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="s1">'Michele'</span><span class="p">,</span>
    <span class="na">sayHi</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hi. I\'m '</span> <span class="o">+</span> <span class="kc">undefined</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">sayHiAlt</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">sayHiAlt</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hi. I\'m '</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>After writing <code class="highlighter-rouge">this</code> article, I can finally say: ES6 doesn’t care about <code class="highlighter-rouge">this</code>.</p>
