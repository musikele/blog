--- layout: default ---

<div id="main">
	<article>
		<header class="major">
			<h2 class="post-title"><a href="/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html">Become a test expert in NodeJS with these tricks</a></h2>
			<p class="post-meta">Mar 27, 2017 • musikele</p>
		</header>

		<section>

			<p>After reading my first guide to 
<a href="https://michelenasti.com/2017/03/23/node-js-testing-easy-with-mocha.html">testing NodeJS with Mocha</a> you might have grasped the fundamental concepts of NodeJS testing. However, <strong>real word code is usually tested with some other expedients</strong> that you might know to be a better tester (and coder).</p>

<h2 id="using-an-assertion-library">Using an assertion library</h2>

<p>In my previous article I wrote how to check the test result: to set a test as failing, you throw a <code class="highlighter-rouge">new Error()</code> object with the message to show.</p>

<p>This is the naive approach; the default is to use an assertion library. These libraries will expose an API that is clearer and simpler to manage, and will let you test more conditions with less code. Under the hood, they will launch the <code class="highlighter-rouge">new Error()</code> if the conditions are not respected.</p>

<p>Let’s see one of these libraries. One of the most famous libraries is called 
<a href="https://github.com/mjackson/expect"><code>expect</code></a>:</p>
<blockquote>
<p>When you use expect, you write assertions similarly to how you would say them, e.g. "I expect this value to be equal to 3" or "I expect this array to contain 3". When you write assertions in this way, you don't need to remember the order of actual and expected arguments to functions like assert.equal, which helps you write better tests.</p>
</blockquote>

<p>Let’s see an example. Here is the test for a <code class="highlighter-rouge">add</code> function, and the test is contained in file <code class="highlighter-rouge">utils.test.js</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//utils.test.js
const expect = require('expect');

const utils = require('./utils');

it('should add two numbers', () =&gt; {
  let res = utils.add(33, 11);

  expect(res).toBe(44).toBeA('number');
});
</code></pre>
</div>

<p>Easier to write, and to reason about. with <code class="highlighter-rouge">expect</code> you can also check if objects have properties, etc. Have a look on their website to see all aviable methods.</p>

<h2 id="testing-async-code">Testing async code</h2>

<p>If you’re using NodeJS, or Javascript, you’re also probably using async functions. No matter if it’s in the form of promises or callbacks, stuff in JS happens async, and we must deal with it.</p>

<p>Let’s prepare an example async function:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//utils.js
module.exports.asyncAdd = (a,b, callback) =&gt; {
  setTimeout(() =&gt; {
    callback(a+b);
  }, 1000);
}

</code></pre>
</div>

<p>How do we test it? The first approach we might think would be to write the test like before:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//utils.test.js
it('should add two numbers', () =&gt; {
  let res = utils.asyncAdd(33, 11, (res) =&gt; {
  
    // will this work? 
    expect(res).toBe(44).toBeA('number'); 
  });
});

</code></pre>
</div>

<p>If you launch this example, <em>the test will pass, but for the <strong>wrong reason</strong></em>. Infact, Mocha will not wait the result callback an will end the test instantly. Try to break the test or the function… Mocha will say that everything is ok. That’s not good.</p>

<p>How can we fix this? Mocha has a super-simple solution, just add a <code class="highlighter-rouge">done</code> argument to the test callback. When <code class="highlighter-rouge">done</code> is present, Mocha will not end the test before you call the <code class="highlighter-rouge">done()</code> function. Let’s try:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//utils.test.js
it('should add two numbers', (done) =&gt; {
  let res = utils.asyncAdd(33, 11, (res) =&gt; {
  
    expect(res).toBe(44).toBeA('number'); 
    done();
  });
});

</code></pre>
</div>

<p>Now, if you try to break the test or the function, you’ll see that Mocha will fail. Exactely what we want.</p>

<h2 id="testing-an-express-application">Testing an Express application</h2>

<p>It’s very difficult for the random developer to write a NodeJS app without using <a href="https://expressjs.com/it/">Express</a>, a framework for web applicatons that allows you to write REST endpoints easily.</p>

<p>How do I test an express application?</p>

<p>the creators of Express have come in help by creating another library called <a href="https://github.com/visionmedia/supertest">supertest</a>:</p>

<blockquote>
  <p> HTTP assertions made easy via superagent.</p>
</blockquote>

<p>Let’s write a simple http application with Express:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">//file server.js</span>
<span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">404</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span>
    <span class="na">error</span><span class="p">:</span> <span class="s1">'Page not found'</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="s1">'hello baby'</span>
  <span class="p">});</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">app</span> <span class="o">=</span> <span class="nx">app</span><span class="p">;</span> <span class="c1">// (1)</span>
</code></pre>
</div>

<p>This simple express app will return a <code class="highlighter-rouge">404</code> error with a json payload, everytime you navigate to <code class="highlighter-rouge">http://localhost:3000/</code>. Why? Because there’s nothing to see, obviously! :p</p>

<p>The only point worth of noting is that we simply export the app, as every other node module. Adding this line at (1) does not break anything, and makes testing possible.</p>

<p>To test this app, let’s write the test using <em>supertest</em>:</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">//server.test.js</span>

<span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'supertest'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">expect</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'expect'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./server'</span><span class="p">);</span>

<span class="nx">it</span><span class="p">(</span><span class="s1">'should return hello world response'</span><span class="p">,</span> <span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">request</span><span class="p">(</span><span class="nx">app</span><span class="p">)</span>          <span class="c1">// (1)</span>
    <span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>           <span class="c1">// (2)</span>
    <span class="c1">//supertest expect!!</span>
    <span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>        <span class="c1">// (3)</span>
    <span class="p">.</span><span class="nx">expect</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>  <span class="c1">// (4)</span>
      <span class="c1">//expect library! </span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">body</span><span class="p">).</span><span class="nx">toInclude</span><span class="p">({</span>
        <span class="na">error</span><span class="p">:</span> <span class="s1">'Page not found'</span>
      <span class="p">})</span>
    <span class="p">})</span>
    <span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">done</span><span class="p">);</span>         <span class="c1">// (5)</span>
<span class="p">});</span>
</code></pre>
</div>

<p>That’s interesting. At (1) we are importing the express app and using <code class="highlighter-rouge">supertest</code> to wrap it. Then we perform a <code class="highlighter-rouge">get</code> request over <code class="highlighter-rouge">/</code> (2) and start expecting things about the result. Unfortunately, supertest has another <code class="highlighter-rouge">expect</code> method that is not related to the one in the <code class="highlighter-rouge">expect</code> library.</p>

<p>By the way, with supertest we can make assumptions about the status code (3), and if we want to assert something about the body of the request, we can do like in (4): when using a callback we can do everything over the <code class="highlighter-rouge">res</code> variable, and infact we are using the <code class="highlighter-rouge">expect</code> library to see if the body includes the <code class="highlighter-rouge">error</code> property.</p>

<p>Since this Mocha test is async, we need a way to tell mocha that the test has ended. In (5) we see that supertest is already aware of mocha and will stop the test by passing the <code class="highlighter-rouge">done</code> function to <code class="highlighter-rouge">end()</code>.</p>

<h2 id="conclusions">Conclusions</h2>

<p>For a novice, the problem of testing Node apps is that there are many libraries the same thing. For an expert, this becomes an advantage: you can choose the best for your purposes (but you must know them in advance).</p>

<p>By the way, testing is important. Test everything is testable. Otherwise, maintaining javascript code can only be a mess.</p>
 
<ul class="share-buttons">
  <li><a href="https://www.facebook.com/sharer/sharer.php?u=https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html&t=" title="Share on Facebook" target="_blank" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html) + '&t=' + encodeURIComponent(document.title)); return false;"><img alt="Share on Facebook" src="/images/icons/Facebook.svg"></a></li>
  <li><a href="https://twitter.com/intent/tweet?source=https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html&text=Become a test expert in NodeJS with these tricks:%20https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html&via=micnasti" target="_blank" title="Tweet" onclick="window.open('https://twitter.com/intent/tweet?text=' + encodeURIComponent(Become a test expert in NodeJS with these tricks) + ':%20'  + encodeURIComponent(https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html)); return false;"><img alt="Tweet" src="/images/icons/Twitter.svg"></a></li>
  <li><a href="https://plus.google.com/share?url=https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html" target="_blank" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=' + encodeURIComponent(https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html)); return false;"><img alt="Share on Google+" src="/images/icons/Google+.svg"></a></li>
  <li><a href="http://www.linkedin.com/shareArticle?mini=true&url=https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html&title=Become a test expert in NodeJS with these tricks&summary=&source=https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html" target="_blank" title="Share on LinkedIn" onclick="window.open('http://www.linkedin.com/shareArticle?mini=true&url=' + encodeURIComponent(https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html) + '&title=' +  encodeURIComponent(document.title)); return false;"><img alt="Share on LinkedIn" src="/images/icons/LinkedIn.svg"></a></li>
</ul>

		</section>

		<section>
			 <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    
    var disqus_config = function () {
    	//var disqus_identifier = 'https://michelenasti.com';
			//var disqus_url = '';
			var disqus_url = 'https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html';
			var disqus_identifier = 'https://michelenasti.com/2017/03/27/become-a-test-expert-in-nodejs-with-these-tricks.html';

    };
    
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//michele-nastis-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript> 
		</section>

		<footer>
			<br> Altri articoli:
			<br>
			<div class="row">
				

				<article class="6u 12u(small) excerpt">
					<header>
						<h2><a href="/2017/03/23/node-js-testing-easy-with-mocha.html">Easy testing of NodeJS applications with Mocha</a></h2>
					</header>
					<section>
						<p>Testing in Javascript has become an immensely popular argument, but still there’s a lot of people that has not clear how to do it effectively. <a href="/2016/08/my-very-personal-javascript-fatigue/">I was one of these</a>. There are many troubles that a young developer has to overcome in order to master Javascript testing. In this article, I’m going to explain Javascript testing with Mocha, a powerful library.</p>


					</section>
					<footer>
						<ul class="actions">
							<li><a href="/2017/03/23/node-js-testing-easy-with-mocha.html" class="button">Read More</a></li>
						</ul>
					</footer>
				</article>
				 

				<article class="6u$ 12u(small) excerpt f-right">
					<header>
						<h2><a href="/2017/04/07/fantastic-unit-tests-in-javascript-with-mocks.html">Fantastic Unit Tests in Javascript with Mocks</a></h2>
					</header>
					<section>
						<p>Let’s start with the example. We have two files, one that is the main one called <code class="highlighter-rouge">app.js</code> that exports just one method, called <code class="highlighter-rouge">handleSignup()</code>:</p>


					</section>
					<footer>
						<ul class="actions">
							<li><a href="//2017/04/07/fantastic-unit-tests-in-javascript-with-mocks.html" class="button">Read More</a></li>
						</ul>
					</footer>
				</article>
				
			</div>
		</footer>

	</article>

</div>